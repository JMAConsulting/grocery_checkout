<?php

define('PAYMENT_INSTANCE', 'iats_credit_card_customer_code|rules_test_future');
define('BATCH', 2);

function grocery_checkout_get_webform_submission($order) {
  $orderID = $order->order_id;
  $lineitems = array();
  
  $result = db_select('webform_submitted_data', 'w')
    ->fields('w', array('cid', 'nid', 'data'))
    ->condition('data', '%"order_id":"' . db_like($orderID) . '"%', 'LIKE')
    ->condition('nid', 517, '=')
    ->execute()
    ->fetchAll();
  if (!empty($result)) {
    foreach ($result as $key => $object) {
      $formkey = db_select('webform_component', 'c')
        ->fields('c', array('form_key'))
        ->condition('cid', $object->cid, '=')
        ->condition('nid', $object->nid, '=')
        ->execute()
        ->fetchAll();
      $json = json_decode($object->data);
      $date = getDates($formkey[0]->form_key);
      if ($date) {
        $price = getPrice($json->line_item_id, $json->quantity);
        $lineitems[$json->line_item_id] = array('dates' => $date, 'charge' => $price, 'order_id' => $orderID);
      }
    }
  }
  return $lineitems;
}

function getPrice($line_item_id, $quantity) {
  $line_item_wrapper = entity_metadata_wrapper('commerce_line_item', $line_item_id);
  $product_wrapper = $line_item_wrapper->commerce_product;
  $charge = commerce_price_wrapper_value($product_wrapper, 'commerce_price', TRUE);
  $price = commerce_currency_amount_to_decimal($charge['amount'], $charge['currency_code']);
  return array('amount' => ($price * $quantity), 'currency' => $charge['currency_code']);
}


function getDates($formkey) {
  $values = explode('_', $formkey);
  $month = $values[0];
  $start = $values[1];
  $end = $values[2];
  $year = "";
  if (in_array($month, array('Oct', 'Nov', 'Dec'))) {
    $year = 2017;
  }
  elseif (in_array($month, array('Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun'))) {
    $year = 2018;
  }
  if ($year) {
    $startDate = date('c', strtotime($start . ' ' . $month . ' ' . $year . ' ' . '00:00:00'));
    $endDate = date('c', strtotime($end . ' ' . $month . ' ' . $year . ' ' . '00:00:00'));
    return array('beginDate' => $startDate, 'endDate' => $endDate);
  }
  return FALSE;
}

function addPayments($response, $payment_method, $payment_data, $order, $lineitems) {
  if ($response != NULL) {

    // Create pending transactions and
    // insert the lineitems in our table for processing future payments.
    foreach ($lineitems as $item_id => $attributes) {
      $transaction = commerce_payment_transaction_new($payment_method['method_id'], $order->order_id);
      $transaction->amount = commerce_currency_decimal_to_amount($attributes['charge']['amount'], $attributes['charge']['currency']);
      $transaction->currency_code = $attributes['charge']['currency'];
      $transaction->line_item_id = $item_id;
      $transaction->payload = array(
        'type' => $payment_data['credit_card']['type'],
      );
      $transaction->status = COMMERCE_PAYMENT_STATUS_PENDING;
      $date = date('jS M Y', strtotime($attributes['dates']['beginDate']));
      $transaction->message = t("Payment will be processed on {$date}");

      // Save the transaction information.
      $pending_payment = commerce_payment_transaction_save($transaction);
      if ($pending_payment) {
        db_merge('grocery_checkout_schedule')
          ->key(array('line_item_id' => $item_id))
          ->fields(array(
            'order_id' => $attributes['order_id'],
            'customer_code' => $response['CUSTOMERCODE'],
            'transaction_id' => $transaction->transaction_id,
            'amount' => $attributes['charge']['amount'] . ' ' . $attributes['charge']['currency'],
            'scheduled_date' => $attributes['dates']['beginDate'],
          ))
          ->execute();
      }
    }
  }
}

function processResponse($response, $payment_method, $payment_id) {
  if ($response != NULL) {
    // Log the payment response.
    if ($payment_method['settings']['log']['response'] === 'response') {
      commerce_iats_log_response($payment_method, $response);
    }

    $auth_result = NULL;
    $transaction_id = NULL;
    $customer_code = NULL;

    if (is_array($response)) {
      if (isset($response['AUTHRESULT'])) {
        // Account for direct debit validation transaction.
        $auth_result = trim($response['AUTHRESULT']['AUTHSTATUS']);
      }
      elseif (isset($response['AUTHORIZATIONRESULT'])) {
        // Account for regular transaction.
        $auth_result = trim($response['AUTHORIZATIONRESULT']);
      }

      $transaction_id = (isset($response['TRANSACTIONID'])) ?
        trim($response['TRANSACTIONID']) : NULL;
      $customer_code = (isset($response['CUSTOMERCODE']) &&
        !empty($response['CUSTOMERCODE'])) ?
        trim($response['CUSTOMERCODE']) : NULL;
    }

    // If AUTHORIZATIONRESULT or AUTHRESULT are not set, then the API returned
    // an error. Assign it here for logging purposes.
    if ($auth_result == NULL) {
      $auth_result = $response;
    }

    // Creating a recurring payment does not result in a transaction ID.
    // Add custom transaction ID here for reference.
    if (($transaction_id == NULL)
      && (isset($payment_method['settings']['allow_recurring'])
        && $payment_method['settings']['allow_recurring'] == 1)) {
      $transaction_id = COMMERCE_IATS_RECURRING_PAYMENT_TRANSACTION_ID;
    }

    // Build the remote ID from the transaction ID and customer code.
    $remote_id = $transaction_id;
    if ($customer_code != NULL) {
      $remote_id .= '|' . $customer_code;
    }

    // Prepare a transaction object to log the API response.
    $transaction = commerce_payment_transaction_load($payment_id);
    $transaction->remote_id = $remote_id;

    if (is_array($auth_result)) {
      if (isset($auth_result['code'])) {
        // Create a failed transaction with the error message.
        $transaction->status = COMMERCE_PAYMENT_STATUS_FAILURE;

        if (isset($payment_method['settings']['detailed_failure_message'])
          && $payment_method['settings']['detailed_failure_message'] == 1) {
          $message = array($auth_result['message']);
        }
        else {
          $message = array('Transaction failed.');
        }
      }
      else {
        $transaction->status = COMMERCE_PAYMENT_STATUS_SUCCESS;
        $message = array('Transaction successful.');
        if (!is_null($customer_code)) {
          $message[] = 'Payment has been processed ' . date('jS M Y', strtotime($response['SETTLEMENTDATE']));
        }
      }
    }
    else {
      if (strpos($auth_result, COMMERCE_IATS_TXN_OK) === 0) {
        $transaction->status = COMMERCE_PAYMENT_STATUS_SUCCESS;
        $message = array('Transaction successful.');
        if (!is_null($customer_code)) {
          $message[] = 'Payment has been processed on ' . date('jS M Y', strtotime($response['SETTLEMENTDATE']));
        }
      }
      else {
        $transaction->status = COMMERCE_PAYMENT_STATUS_FAILURE;
        $message = array('Transaction failed.') . $auth_result;
      }
    }

    $transaction->message .= '<br/>' . implode('<br />', $message);
    // Save the transaction information.
    commerce_payment_transaction_save($transaction);

    // If the payment failed, display an error and rebuild the form.
    if ($transaction->status != COMMERCE_PAYMENT_STATUS_SUCCESS) {
      if (is_array($auth_result)) {
        $error_reason = $auth_result['message'];
        if (isset($response['AUTHRESULT']['BANKERROR'])) {
          $error_reason .= ': ' . $response['AUTHRESULT']['BANKERROR'];
        }
      }
      else {
       $error_reason = $auth_result;
      }

      watchdog(
        t('We received the following error while attempting to process your payment: @reason for payment id: @payment_id',
          array('@reason' => $error_reason, '@payment_id' => $payment_id)),
        WATCHDOG_ERROR
      );
      return FALSE;
    }
  }
  else {
    watchdog(
      t('We encountered an error contacting our payment processor. Please try submitting your payment again.'),
      WATCHDOG_ERROR
    );
    return FALSE;
  }
}

function grocery_checkout_cron() {
  // Check if pending order date matches current date.
  $query = db_select('grocery_checkout_schedule', 'g')
    ->fields('g')
    ->fields('p', array('payload'))
    ->condition('p.status', 'pending', '=')
    ->condition('g.is_cancelled', 0, '=')
    ->range(0, BATCH);
  $query->innerJoin('commerce_payment_transaction', 'p', 'p.transaction_id = g.transaction_id');
  $result = $query->execute()->fetchAll();
  $payment_method = commerce_payment_method_instance_load(PAYMENT_INSTANCE);
  if (!empty($result)) {
    foreach ($result as $id => $object) {
      $payload = unserialize($object->payload);
      $amount = explode(' ', $object->amount);
      $request = array(
        'customerIPAddress' => ip_address(),
        'customerCode' => $object->customer_code,
        'invoiceNum' => $object->transaction_id,
        'mop' => $payload['type'],
        'total' => $amount[0],
        'comment' => 'Order ID ' . $object->order_id,
        'currency' => $amount[1],
      );
      $iats = commerce_iats_get_service('ProcessLink', $payment_method);
      if ($iats == NULL) {
        watchdog('grocery_checkout', t('Unable to load iATS Payments library.'), WATCHDOG_ERROR);
        return NULL;
      }

      $response = $iats->processCreditCardWithCustomerCode($request);
      processResponse($response, $payment_method, $object->transaction_id); 
    }
  }
}
